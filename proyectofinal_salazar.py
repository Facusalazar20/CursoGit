# -*- coding: utf-8 -*-
"""ProyectoFinal_Salazar.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UhKgL3-9vMZcrJfCbG91-49CdK0curUa

### OBJETIVO DEL PROYECTO:

El objetivo del proyecto es generar un predictor que permita conocer con anterioridad que jugadores seran titulares en la proxima temporada en sus respectivos equipos. Para ello, utilizare técnicas de análisis de datos y machine learninng para encontrar patrones en las estadisticas brindadas por la base de datos.

En este proyecto se utilizara como base de datos "2021-2022 European Leagues Player Stats" extraido de kaggle, el cual incluye una tabla, la cual posee datos de jugadores de fútbol de 2021-2022 por 90 minutos. Solo se enumeran jugadores de Premier League, Ligue 1, Bundesliga, Serie A y La Liga. La base de datos esta conformada por 2500 filas y 143 columnas.

Las columnas son:

Rk : Rank

Player : Player's name

Nation : Player's nation

Pos : Position

Squad : Squad’s name

Comp : League that squat occupies

Age : Player's age

Born : Year of birth

MP : Matches played

Starts : Matches started

Min : Minutes played

90s : Minutes played divided by 90

Goals : Goals scored or allowed

Shots : Shots total (Does not include penalty kicks)

SoT : Shots on target (Does not include penalty kicks)

SoT% : Shots on target percentage (Does not include penalty kicks)

G/Sh : Goals per shot

G/SoT : Goals per shot on target (Does not include penalty kicks)

ShoDist : Average distance, in yards, from goal of all shots taken (Does not include penalty kicks)

ShoFK : Shots from free kicks

ShoPK : Penalty kicks made

Las variables descriptas anteriormente, son una muestra de la gran variedad de estadisticas que se encuentran desarrolladas en la base de datos. Las columnas, se pueden agrupar en conjuntos, principalmente relacionado a la posicion del jugador. Es decir, para un delantero, se lo puede asociar a columnas que expresen datos como los siguientes, tiros al arco, goles, asistencias.

### Contexto Comercial

En la actualidad, conocer las futuras titularidades de los jugadores de futbol, plantea diferentes ventajas, algunas de ellas son:

Planificación táctica: Si sabes con anticipación qué jugadores estarán disponibles para la próxima temporada, puedes planificar estratégicamente cómo configurar tu equipo para obtener el mejor rendimiento posible. Puedes diseñar tácticas y esquemas de juego que se ajusten a las habilidades de tus jugadores clave y minimizar el impacto de la ausencia de aquellos que no estarán disponibles.

Planificación financiera: Si conoces de antemano los jugadores que estarán en el equipo titular, también puedes planificar los recursos financieros necesarios para reforzar el equipo en caso de que sea necesario. Esto puede incluir la búsqueda de jugadores de calidad que puedan complementar las habilidades del equipo titular y asegurar la profundidad del plantel en caso de lesiones o suspensiones.

Ventaja competitiva: Al saber qué jugadores estarán disponibles, puedes prepararte mejor para enfrentar a tus rivales directos. Puedes estudiar a los jugadores clave de los equipos rivales y desarrollar estrategias específicas para minimizar su impacto en el juego. También puedes identificar oportunidades para explotar las debilidades de los equipos rivales y maximizar el potencial de tu propio equipo.

En resumen, conocer de antemano qué jugadores serán titulares en la próxima temporada puede ayudarte a planificar mejor tácticamente, financieramente y obtener una ventaja competitiva sobre tus rivales en el mundo del fútbol.

### Hipotesis

La creación de un predictor de titularidades de los distintos jugadores de futbol de los equipos de las 5 grandes ligas, permitira contar con una gran ventaja a la hora de planificar tacticamente y financieramente tu respectivo equipo para la temporada entrante?

### DataSet
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
futbol = pd.read_csv('/content/2021-2022+Football+Player+Stats.csv')
futbol

"""### Exploración de datos

Analisis univariado, bivariado, obtención de Insights a partir de visualizaciones
"""

import pandas as pd
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import seaborn as sns

Gol_Del = futbol[(futbol['Pos'] == "FW")] [['Player','Goals','MP' ]]


Gol_Del['GoalMP'] = Gol_Del['MP'] * Gol_Del['Goals']

"""A continuación el gráfico representa los 30 jugadores con mayor número de goles."""

goles_por_jugador = Gol_Del .groupby('Player')['GoalMP'].sum()
resultados = goles_por_jugador.sort_values(ascending=False).head(30)
fig, ax = plt.subplots()



ax.barh(resultados.index, resultados.values)


ax.set_xlabel('Goles')
ax.set_title('Top 30 goleadores')


ax.invert_yaxis()
ax.set_xlim([0, max(resultados.values) + 5])


plt.show()

"""En el siguiente gráfico, se visualiza una comparativa de los jugadores con una máxima cantidad de asistencias + goles en las 5 grandes ligas.

"""

Del = futbol[(futbol['Pos'] == "FW")] [['Player','Goals','MP','Assists','Squad','Age']]


Del['GoalMP'] = Del['MP'] * Del['Goals']
Del['AssistMP'] = Del['MP'] * Del['Assists']

Del['goles_asistencias'] = Del['GoalMP'] + Del['AssistMP']
Del = Del.sort_values(by='goles_asistencias', ascending=False)


top_jugadores = Del.head(30)


fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(top_jugadores['Player'], top_jugadores['GoalMP'], label='Goles')
ax.bar(top_jugadores['Player'], top_jugadores['AssistMP'], label='Asistencias')

ax.set_title('Goles y asistencias de los 30 mejores jugadores')
ax.set_xlabel('Jugador')
ax.set_ylabel('Cantidad')
ax.legend()
ax.set_xticklabels(top_jugadores['Player'], rotation='vertical')

"""El siguiente grafico  exhibe todos los equipos que cuentan con 1 o más jugadores que poseen más de 1 asistencia y 1 gol."""

top_jugadores = Del.loc[(Del['GoalMP'] > 1) & (Del['AssistMP'] > 1)].sort_values(by=['GoalMP', 'AssistMP'], ascending=False).head(30)


top_equipos = top_jugadores.groupby('Squad')['Player'].count()


fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(top_equipos.index, top_equipos.values)


ax.set_title("Equipos con más jugadores con más de 1 goles y asistencias")
ax.set_xlabel("Equipo")
ax.set_ylabel("Cantidad de jugadores")
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)
ax.tick_params(axis='x', rotation=90)

plt.show()

"""A continuación se representa los principales delanteros de futbol, que cuentan con una mayor cantidad de goles y asistencias, con una edad menor a 25 años."""

edad_limite = 25
jugadores_jovenes = Del[Del["Age"] <= edad_limite]


jugadores_top = jugadores_jovenes.nlargest(10, ["GoalMP", "AssistMP"])


fig, ax = plt.subplots()


ax.bar(jugadores_top["Player"], jugadores_top["GoalMP"], label="Goles")
ax.bar(jugadores_top["Player"], jugadores_top["AssistMP"], bottom=jugadores_top["GoalMP"], label="Asistencias")


ax.set_ylabel("Cantidad")
ax.tick_params(axis='y', labelsize=8)


ax.set_xticklabels(jugadores_top["Player"], rotation=90, ha='center')


ax.legend()


plt.show()

"""Para concluir, los gráficos realizados brindan un punto de partida para que en un futuro se pueda efectuar predicciones de titularidad de los jugadores, teniendo en cuenta sus estadísticas principales. Cabe aclarar que el ejemplo se realizó únicamente para los delanteros, con el fin de dar un pantallazo general.

En el grafico siguiente, se buscó profundizar el análisis, considerando todas las posiciones, y para cada una analizar una estadística fundamental.
"""

futbol['GoalMP'] = futbol['MP'] * futbol['Goals']
futbol['AssistMP'] = futbol['MP'] * futbol['Assists']
futbol['ClrMP'] = futbol['MP'] * futbol['Clr']
futbol['PasTotCmpMP'] = futbol['MP'] * futbol['PasTotCmp']
futbol['IntMP'] = futbol['MP'] * futbol['Int']

grupo_delanteros = futbol[futbol['Pos'] == 'FW'].groupby('Player').sum().sort_values(by='GoalMP', ascending=False)
grupo_mediocampistas = futbol[futbol['Pos'] == 'MF'].groupby('Player').sum().sort_values(by='AssistMP', ascending=False)
grupo_defensores = futbol[futbol['Pos'] == 'DF'].groupby('Player').sum().sort_values(by='ClrMP', ascending=False)
grupo_arqueros = futbol[futbol['Pos'] == 'GK'].groupby('Player').sum().sort_values(by='MP', ascending=False)

top_goleadores = grupo_delanteros.head(5)
top_asistidores = grupo_mediocampistas.head(5)
top_despejadores = grupo_defensores.head(5)
top_atajadores = grupo_arqueros.head(5)

fig, axs = plt.subplots(2, 2, figsize=(10, 10))
axs[0, 0].bar(top_goleadores.index, top_goleadores['GoalMP'])
axs[0, 0].set_title('Top 5 de goleadores de las 5 grandes ligas ')
axs[0, 0].tick_params(axis='x', rotation=90)
axs[0, 1].bar(top_asistidores.index, top_asistidores['AssistMP'])
axs[0, 1].set_title('Top 5 de asistidores de las 5 grandes ligas')
axs[0, 1].tick_params(axis='x', rotation=90)
axs[1, 0].bar(top_despejadores.index, top_despejadores['ClrMP'])
axs[1, 0].set_title('Top 5 de despejadores de las 5 grandes ligas')
axs[1, 0].tick_params(axis='x', rotation=90)
axs[1, 1].bar(top_atajadores.index, top_atajadores['MP'])
axs[1, 1].set_title('Top 5 de atajadores de las 5 grandes ligas')
axs[1, 1].tick_params(axis='x', rotation=90)
plt.subplots_adjust(wspace=0.4, hspace=0.6)
plt.show()

"""Basándose en el grafico anterior, se podrían incluir aún más estadísticas a la hora de tener en cuenta que jugador adquirir, de acuerdo a su posición."""

futbol['GoalMP'] = futbol['MP'] * futbol['Goals']
futbol['AssistMP'] = futbol['MP'] * futbol['Assists']
futbol['ClrMP'] = futbol['MP'] * futbol['Clr']
futbol['PasTotCmpMP'] = futbol['MP'] * futbol['PasTotCmp']
futbol['IntMP'] = futbol['MP'] * futbol['Int']


delanteros = futbol[futbol['Pos'] == 'FW']
delanteros = delanteros.groupby('Player').sum()
delanteros['Goles + Asistencias'] = delanteros['GoalMP'] + delanteros['AssistMP']
delanteros = delanteros.sort_values('Goles + Asistencias', ascending=False)[:5]


mediocampistas = futbol[futbol['Pos'] == 'MF']
mediocampistas = mediocampistas.groupby('Player').sum()
mediocampistas['Asistencias + Pases Completados'] = mediocampistas['AssistMP'] + mediocampistas['PasTotCmpMP']
mediocampistas = mediocampistas.sort_values('Asistencias + Pases Completados', ascending=False)[:5]


defensores = futbol[futbol['Pos'] == 'DF']
defensores = defensores.groupby('Player').sum()
defensores['Despejes + Intercepciones'] = defensores['ClrMP'] + defensores['IntMP']
defensores = defensores.sort_values('Despejes + Intercepciones', ascending=False)[:5]


arqueros = futbol[futbol['Pos'] == 'GK']
arqueros = arqueros.groupby('Player').sum()
arqueros = arqueros.sort_values('MP', ascending=False)[:5]


fig, axes = plt.subplots(2, 2, figsize=(12, 12))
axes = axes.flatten()


axes[0].bar(delanteros.index, delanteros['GoalMP'], label='Goles')
axes[0].bar(delanteros.index, delanteros['AssistMP'], label='Asistencias', bottom=delanteros['GoalMP'])
axes[0].set_title('Delanteros con más goles y asistencias')
axes[0].set_xlabel('Jugador')
axes[0].set_ylabel('Goles y Asistencias')
axes[0].tick_params(axis='x', rotation=90)
axes[0].legend()


axes[1].bar(mediocampistas.index, mediocampistas['AssistMP'], label='Asistencias')
axes[1].bar(mediocampistas.index, mediocampistas['PasTotCmpMP'], label='Pases Completados', bottom=mediocampistas['AssistMP'])
axes[1].set_title('Mediocampistas con más asistencias y pases completados')
axes[1].set_xlabel('Jugador')
axes[1].set_ylabel('Asistencias y Pases Completados')
axes[1].tick_params(axis='x', rotation=90)
axes[1].legend()


axes[2].bar(defensores.index, defensores['ClrMP'], label='Despejes')
axes[2].bar(defensores.index, defensores['IntMP'], label='Intercepciones', bottom=defensores['ClrMP'])
axes[2].set_title('Defensores con más Despejes e intercepciones')
axes[2].set_xlabel('Jugador')
axes[2].set_ylabel('Despejes e intercepciones')
axes[2].tick_params(axis='x', rotation=90)
axes[2].legend()

axes[3].bar(arqueros.index, arqueros['MP'], label='Partidos jugados')
axes[3].set_title('Arqueros con más partidos jugados')
axes[3].set_xlabel('Jugador')
axes[3].set_ylabel('Partidos jugados')
axes[3].tick_params(axis='x', rotation=90)
axes[3].legend()

plt.subplots_adjust(wspace=0.4, hspace=0.6)

plt.show()

"""Centrándonos nuevamente en la posición del jugador, se puede analizar la efectividad del jugador, en determinados aspectos interesantes."""

futbol['GoalMP'] = futbol['MP'] * futbol['Goals']
futbol['ShotsMP'] = futbol['MP'] * futbol['Shots']
futbol['PasTotCmpMP'] = futbol['MP'] * futbol['PasTotCmp']
futbol['PasTotAttMP'] = futbol['MP'] * futbol['PasTotAtt']

delanteros = futbol[futbol['Pos'] == 'FW']

delanteros['Goles x Tiro %'] = delanteros['GoalMP'] / delanteros['ShotsMP'] * 100
delanteros['Pases Completados %'] = delanteros['PasTotCmpMP'] / delanteros['PasTotAttMP'] * 100
delanteros['Cabezazos Ganados %'] = delanteros['AerWon%']
delanteros['Puntuación'] = delanteros['Goles x Tiro %'] + delanteros['Pases Completados %'] + delanteros['AerWon%']

top_goles = delanteros.sort_values('Goles x Tiro %', ascending=False).head(5)
top_pases = delanteros.sort_values('Pases Completados %', ascending=False).head(5)
top_cabezazos = delanteros.sort_values('Cabezazos Ganados %', ascending=False).head(5)
top_puntuacion = delanteros.sort_values('Puntuación', ascending=False).head(5)

fig, axs = plt.subplots(2, 2, figsize=(10, 8))

axs[0, 0].barh(top_goles['Player'], top_goles['Goles x Tiro %'], color='red')
axs[0, 0].set_xlabel('Goles x Tiro %')
axs[0, 1].barh(top_pases['Player'], top_pases['Pases Completados %'], color='blue')
axs[0, 1].set_xlabel('Pases Completados %')
axs[1, 0].barh(top_cabezazos['Player'], top_cabezazos['Cabezazos Ganados %'], color='green')
axs[1, 0].set_xlabel('Cabezazos Ganados %')
axs[1, 1].barh(top_puntuacion['Player'], top_puntuacion['Puntuación'], color='purple')
axs[1, 1].set_xlabel('Puntuación')

plt.tight_layout()
plt.show()

"""En el grafico anterior, se puede visualizar una comparativa de los jugadores que poseen una mejor eficiencia en términos de, goles * tiro, pases completados vs pases intentados y en cabezazos ganados vs intentados. Finalmente se obtiene una puntuación final, la cual suma la eficiencia de todos los jugadores y brinda el top 5 de jugadores que cuentan con la mayor eficiencia en todas estas estadísticas.

Todos los gráficos efectuados, actúan como punto de partida para que en un futuro se puedan predecir titularidades, en función de las estadísticas de los jugadores. Si se toma como ejemplo el último gráfico, si se quisiera comprar un jugador para el futuro teniendo en cuenta la eficiencia del mismo en las estadísticas ya explicadas, seguramente un analista se puede guiar por el grafico de puntuación para adquirir el jugador.

Análisis de nulos
"""

futbol.isnull().sum()

futbol[(futbol.Rk == 62)]['Nation']

futbol1 = futbol.set_index('Rk')
futbol1

Del = futbol1[(futbol1['Pos'] == "FW")] [['Player','Goals','Assists','MP','SoT']]
Del['GoalMP'] = Del['MP'] * Del['Goals']
Del['AssistMP'] = Del['MP'] * Del['Assists']
Del['SoTMP']=Del['MP'] * Del['SoT']

Del.drop([ 'Goals', 'Assists', 'MP','SoT'], axis=1, inplace=True)

X = Del

"""Normalizado"""

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
X['Player'] = le.fit_transform(X['Player'])

X.head()

"""Se elimina columna jugador"""

cols_num=[x for x in X.columns if x!='Player']
cols_num

"""Detección de Outliers"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error

from sklearn.ensemble import IsolationForest

iso = IsolationForest(contamination=0.1)
yhat = iso.fit_predict(X)
X_sin_outliers = X[yhat != -1]

"""Se analiza correlación con base de datos sin Outliers"""

Corr = X_sin_outliers.corr()

sns.heatmap(Corr, annot=True, cmap='coolwarm')
plt.title('Matriz de correlación')
plt.show()

"""Es factible visualizar elevada correlación entre tiros al arco y goles.

### Desarrollo de modelos

**Modelo de regresión**
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score



X_sin_outliers['Puntuacion'] = X_sin_outliers['GoalMP'] + X_sin_outliers['AssistMP'] + X_sin_outliers['SoTMP']


columnas_caracteristicas = ['GoalMP', 'AssistMP', 'SoTMP']
variable_objetivo = 'Puntuacion'


X = X_sin_outliers[columnas_caracteristicas]
y = X_sin_outliers[variable_objetivo]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)


modelo = RandomForestRegressor(n_estimators=100, random_state=42)


modelo.fit(X_train, y_train)


y_pred = modelo.predict(X_test)



mse = mean_squared_error(y_test, y_pred)
print("Error cuadrático medio (MSE):", mse)

"""Teniendo en cuenta el MSE, el valor es cercano a 0. Debido a que el problema que se desea predecir no funciona con un modelo de regresión, se desestima el modelo. No obstante, se optimizara el mismo con XGBOOST y Grid Search para mejorar el error."""

predicciones = pd.DataFrame({'Puntuacion Real': y_test, 'Puntuacion Predicha': y_pred})
print(predicciones)

"""XGBOOST"""

from sklearn.metrics import mean_squared_error
import xgboost as xgb

X_sin_outliers['Puntuacion'] = X_sin_outliers['GoalMP'] + X_sin_outliers['AssistMP'] + X_sin_outliers['SoTMP']


columnas_caracteristicas = ['GoalMP', 'AssistMP', 'SoTMP']
variable_objetivo = 'Puntuacion'

X = X_sin_outliers[columnas_caracteristicas]
y = X_sin_outliers[variable_objetivo]


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)


modelo_xgb = xgb.XGBRegressor(n_estimators=100, random_state=42)


modelo_xgb.fit(X_train, y_train)


y_pred_xgb = modelo_xgb.predict(X_test)


mse_xgb = mean_squared_error(y_test, y_pred_xgb)
print("Error cuadrático medio (MSE) con XGBoost:", mse_xgb)


mse_rf = mean_squared_error(y_test, y_pred)
print("Error cuadrático medio (MSE) con RandomForestRegressor:", mse_rf)

"""Optimizamos modelo con search grid"""

from sklearn.model_selection import GridSearchCV
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error


columnas_caracteristicas = ['GoalMP', 'AssistMP', 'SoTMP']
variable_objetivo = 'Puntuacion'

X = X_sin_outliers[columnas_caracteristicas]
y = X_sin_outliers[variable_objetivo]


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)


modelo = XGBRegressor()


parametros = {
    'n_estimators': [50, 100, 150],
    'max_depth': [3, 5, 7],
    'learning_rate': [0.1, 0.01, 0.001]
}


grid_search = GridSearchCV(modelo, parametros, scoring='neg_mean_squared_error', cv=5)


grid_result = grid_search.fit(X_train, y_train)


mejores_parametros = grid_result.best_params_
mejor_modelo = grid_result.best_estimator_


y_pred_optimizado = mejor_modelo.predict(X_test)


mse_optimizado = mean_squared_error(y_test, y_pred_optimizado)
print("Error cuadrático medio (MSE) con el modelo optimizado:", mse_optimizado)

"""Se visualiza una mejoria en el error cuadratico medio al aplicar XGboosting, obteniendo un valor de 2,26. En adición al aplicar grid search, el valor de MSE reduce a 1,4, se optimiza el error."""

n = X_test.shape[0]
k = X_test.shape[1]
grid_search = GridSearchCV(modelo_xgb, parametros, scoring='neg_mean_squared_error', cv=5)
grid_result = grid_search.fit(X_train, y_train)

mejores_parametros = grid_result.best_params_
mejor_modelo_xgb = grid_result.best_estimator_
y_pred_xgb_optimizado = mejor_modelo_xgb.predict(X_test)


r2_adj_xgb_optimizado = 1 - (1 - r2_score(y_test, y_pred_xgb_optimizado)) * (n - 1) / (n - k - 1)
print("R2 ajustado para el modelo con XGBoost optimizado:", r2_adj_xgb_optimizado)

"""Con fines del proyecto se calcula R2 ajustado al modelo de regresión, el valor del mismo es de 1.

**PCA**
"""

X_sin_outliers.drop([ 'Puntuacion','Player'], axis=1, inplace=True)

import numpy as np
import pandas as pd
import statsmodels.api as sm


import matplotlib.pyplot as plt
import matplotlib.font_manager
from matplotlib import style
style.use('ggplot') or plt.style.use('ggplot')


from sklearn.decomposition import PCA
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import scale


import warnings
warnings.filterwarnings('ignore')

pca_pipe = make_pipeline(StandardScaler(), PCA())
pca_pipe.fit(X_sin_outliers)


modelo_pca = pca_pipe.named_steps['pca']

pca_pipe.named_steps['pca']

pca_pipe.fit(X_sin_outliers)

pd.DataFrame(
    data    = modelo_pca.components_,
    columns = X_sin_outliers.columns,
    index   = ['PC1', 'PC2', 'PC3']
)

fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 5))
componentes = modelo_pca.components_
plt.imshow(componentes.T, cmap='seismic', aspect='auto')
plt.yticks(range(len(X_sin_outliers.columns)), X_sin_outliers.columns)
plt.xticks(range(len(X_sin_outliers.columns)), np.arange(modelo_pca.n_components_) + 1)
plt.grid(False)
plt.colorbar();

modelo_pca.n_components_

modelo_pca.explained_variance_ratio_

prop_varianza_acum = modelo_pca.explained_variance_ratio_.cumsum()
prop_varianza_acum

proyecciones = pca_pipe.transform(X=X_sin_outliers)
proyecciones = pd.DataFrame(
    proyecciones,
    columns = ['PC1', 'PC2', 'PC3'],
    index   = X_sin_outliers.index
)
proyecciones.head()

proyecciones = np.dot(modelo_pca.components_, scale(X_sin_outliers).T)
proyecciones = pd.DataFrame(proyecciones, index = ['PC1', 'PC2', 'PC3'])
proyecciones = proyecciones.transpose().set_index(X_sin_outliers.index)
proyecciones.head()

proyecciones['val']=proyecciones.index
print(proyecciones.head())

import matplotlib.pyplot as plt


plt.scatter(proyecciones['PC1'], proyecciones['PC2'], c='blue', label='PC1 vs PC2')


plt.xlabel('Componente Principal 1')
plt.ylabel('Componente Principal 2')
plt.title('Proyecciones en Componentes Principales')


plt.legend()


plt.show()

"""**Hierarchical_clustering**"""

feature_mtx=X_sin_outliers.values
feature_mtx

import scipy
leng = feature_mtx.shape[0]
D = scipy.zeros([leng,leng])
for i in range(leng):
    for j in range(leng):
        D[i,j] = scipy.spatial.distance.euclidean(feature_mtx[i], feature_mtx[j])

import pylab
import scipy.cluster.hierarchy
Z = scipy.cluster.hierarchy.linkage(D, 'complete')

from scipy.cluster.hierarchy import fcluster
k = 5
clusters = fcluster(Z, k, criterion='maxclust')
clusters

from scipy.spatial import distance_matrix
dist_matrix = distance_matrix(feature_mtx,feature_mtx)
print(dist_matrix)

from sklearn import preprocessing
import scipy.cluster.hierarchy as sch
from sklearn.cluster import AgglomerativeClustering

agglom = AgglomerativeClustering(n_clusters = 5, linkage = 'complete',affinity='euclidean')
agglom.fit(feature_mtx)
agglom.labels_

X_sin_outliers['cluster_'] = agglom.labels_
X_sin_outliers.head()

X_sin_outliers.groupby(['cluster_'])['cluster_'].size()

agg_cars = X_sin_outliers.groupby(['cluster_'])['GoalMP','AssistMP','SoTMP'].mean()
agg_cars

import matplotlib.pyplot as plt


agg_cars = X_sin_outliers.groupby('cluster_')[['GoalMP', 'AssistMP','SoTMP']].mean()


agg_cars.plot(kind='bar')


plt.xlabel('Cluster')
plt.ylabel('Promedio')
plt.title('Promedio de GoalMP y AssistMP por Cluster')


plt.show()

"""**K-Means**"""

from sklearn.cluster import KMeans

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd

from sklearn.cluster import KMeans
from sklearn.metrics import davies_bouldin_score,silhouette_score,silhouette_samples,calinski_harabasz_score
from sklearn.preprocessing import StandardScaler

import matplotlib.pyplot as plt
import matplotlib.cm as cm

import warnings
warnings.filterwarnings("ignore")
# %matplotlib inline

sse,db,slc,cal = {}, {}, {}, {}
for k in range(2, 10):

    kmeans = KMeans(n_clusters=k, max_iter=1000,random_state=10).fit(X_sin_outliers)

    clusters = kmeans.labels_
    sse[k] = kmeans.inertia_
    db[k] = davies_bouldin_score(X_sin_outliers,clusters)
    slc[k] = silhouette_score(X_sin_outliers,clusters)
    cal[k] = calinski_harabasz_score(X_sin_outliers,clusters)

plt.figure(figsize=(12,6))
plt.subplot(2,2,1)
plt.plot(list(sse.keys()), list(sse.values()),marker='s')
plt.xlabel("Numero de clusters")
plt.ylabel("SSE")
plt.subplot(2,2,2)
plt.plot(list(db.keys()), list(db.values()),marker='o')
plt.xlabel("Numero de clusters")
plt.ylabel("Indice Davies-Bouldin")
plt.subplot(2,2,3)
plt.plot(list(slc.keys()), list(slc.values()),marker='s')
plt.xlabel("Numero de clusters")
plt.ylabel("Score de Silhouette")
plt.subplot(2,2,4)
plt.plot(list(cal.keys()), list(cal.values()),marker='s')
plt.xlabel("Numero de clusters")
plt.ylabel("Caliniski Harabaz")

"""Se puede concluir lo siguiente para las métricas de calidad realizadas:

*   Métrica Score de Silhouette: Nos indica si un registro está bien asignado, por lo que visualizando el grafico, el número adecuado de cluster es de 2.
*   Índice de Calinski-Harabasz: Cuanto más elevado su valor, mejor será el desempeño del segmentado. Los valores óptimos se encuentran entre 2 y 5 cluster.
*   Índice de Davies-Bouldin: Los clusters que estén más alejados y menos dispersos darán una mejor puntuación. Numero de cluster con mayor puntuación es 8.

Analizando las distintas métricas de calidad en cuanto al modelo, el número de cluster a utilizar será de 2, debido a fines del proyecto, ya que es necesario contar con 2 cluster con la finalidad de agrupar en titulares y no titulares.
"""

kmeans = KMeans(n_clusters=2, random_state=42)
kmeans.fit(X_sin_outliers)

cluster_labels = kmeans.labels_

X_sin_outliers['cluster_label'] = cluster_labels
cluster_stats = X_sin_outliers.groupby('cluster_label')[['GoalMP', 'AssistMP','SoTMP']].mean()
print(cluster_stats)

X_sin_outliers.head()

X_sin_outliers = X_sin_outliers.reset_index()

x = X_sin_outliers['Rk']
y1 = X_sin_outliers['GoalMP']
y2 = X_sin_outliers['AssistMP']
y3 = X_sin_outliers['SoTMP']
cluster_labels = X_sin_outliers['cluster_label']


color_mapping = {
    0: 'red',
    1: 'blue'

}


plt.scatter(x, y1, c=[color_mapping[label] for label in cluster_labels], label='GoalMP')


plt.xlabel('Player')
plt.ylabel('Goals per Match')


plt.title('Gráfico de Dispersión de GoalMP con Colores según Cluster')


legend_labels = ['Titular', 'No Titular']
legend_colors = ['red', 'blue']
custom_legend = [plt.Line2D([], [], marker='o', color='w', markerfacecolor=color, markersize=10) for color in legend_colors]
plt.legend(custom_legend, legend_labels)


plt.show()


plt.scatter(x, y2, c=[color_mapping[label] for label in cluster_labels], label='AssistMP')


plt.xlabel('Player')
plt.ylabel('Assists per Match')


plt.title('Gráfico de Dispersión de AssistMP con Colores según Cluster')


plt.legend(custom_legend, legend_labels)


plt.show()

plt.scatter(x, y3, c=[color_mapping[label] for label in cluster_labels], label='SoTMP')


plt.xlabel('RK')
plt.ylabel('Shots per match')


plt.title('Gráfico de Dispersión de SoTMP con Colores según Cluster')


plt.legend(custom_legend, legend_labels)


plt.show()

"""En los diagramas, se puede visualizar la dispersión existente entre  goles, asistencias y tiros por jugador. Graficamente se plasma  aquellos jugadores que poseen una mayor cantidad de goles, asistencias u tiros al arco como titulares, es decir, teniendo en cuenta sus estadisticas el modelo determina si los jugadores seran o no titulares."""

silhouette = silhouette_score(X_sin_outliers, cluster_labels)
davies_bouldin = davies_bouldin_score(X_sin_outliers, cluster_labels)
calinski_harabasz = calinski_harabasz_score(X_sin_outliers, cluster_labels)
metric_names = ['Silueta', 'Davies-Bouldin', 'Calinski-Harabasz']
metric_values = [silhouette, davies_bouldin, calinski_harabasz]


plt.bar(metric_names, metric_values)
plt.ylabel('Valor de la métrica')
plt.title('Métricas de calidad del clustering')

plt.show()

"""Analizando las metricas de calidad obtenidas del modelo se pueden obtener las siguientes conclusiones:


  

*    Metrica Silueta: Un valor cercano a 1 indica una buena separación de los clusters, donde las muestras están más cerca de su propio cluster y lejos de otros clusters. En el grafico se visualiza un valor cercano a 0, lo cual es satisfactorio.
*    Índice de Davies-Bouldin: Un valor cercano a 0 indica una buena
separación de los clusters, mientras que valores más altos indican una mayor superposición o confusión entre los clusters. En este caso se obtiene un valor de 17.
*   Coeficiente de Calinski-Harabasz: Un valor más alto indica una mejor estructura de clustering.Se obtene un valor cercano a 2.5

Teniendo en cuenta las conclusiones, para determinar si el modelo es bueno o malo, se debe comparar con otros modelos, ya que por sí solo las métricas no alcanzan. Sin embargo, los demás modelos utilizados como ser, PCA, Regresión y Hierarchical_clustering no cumplen la finalidad del proyecto, el cual es predecir 2 grupos mediante aprendizaje no supervisado.

### Conclusion Final

Contemplando el objetivo del proyecto, el cual era contar con un predictor que determine la titularidad de un jugador en función de sus respectivas estadísticas, lo mismo es factible de alcanzar con un modelo K-mean. Al analizar los gráficos expuestos con anterioridad, se visualiza claros patrones en los datos en cuanto a la correcta predicción, ya que aquellos jugadores con niveles mayores en sus estadísticas, se exhiben como titulares. En cuanto a la hipótesis, con un correcto funcionamiento del predictor, un asesor podrá contar con los jugadores con las mejores estadísticas, lo que se traduce en una ventaja competitiva para cualquier equipo de futbol.
"""